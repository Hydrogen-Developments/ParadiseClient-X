package net.paradise_client.exploit;

import net.minecraft.client.MinecraftClient;
import net.paradise_client.Helper;
import net.paradise_client.ParadiseClient;
import net.paradise_client.exploit.impl.*;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Manages and handles various exploits.
 *
 * @author SpigotRCE
 * @since 2.5
 */
public class ExploitRegistry {
    private final MinecraftClient minecraftClient;

    /**
     * A list of all available exploits.
     */
    private final ArrayList<Exploit> exploits = new ArrayList<>();

    /**
     * Constructs a new ExploitManager with the given exploits.
     */
    public ExploitRegistry(MinecraftClient minecraftClient) {
        this.minecraftClient = minecraftClient;
    }

    public void init() {
        register(new BrigadierExploit(minecraftClient));
        register(new PaperWindowExploit(minecraftClient));
        register(new SignExploit(minecraftClient));
        register(new NegativeInfinityExploit(minecraftClient));
        register(new VelocityReportExploit(minecraftClient));
        register(new ViaVersionExploit(minecraftClient));
    }

    /**
     * Executes the exploit with the specified alias.
     *
     * @param alias The alias of the exploit to execute.
     * @throws IllegalArgumentException if the alias is null or empty.
     */
    public void handleExploit(String alias) {
        if (alias == null || alias.trim().isEmpty()) {
            throw new IllegalArgumentException("Exploit alias cannot be null or empty");
        }
        Exploit exploit = getExploit(alias);
        if (exploit == null) {
            Helper.printChatMessage("Unknown exploit: " + alias);
            return;
        }
        ParadiseClient.EXPLOIT_MOD.isRunning = true;
        exploit.execute();
    }

    /**
     * Retrieves the exploit with the specified alias (case-insensitive).
     *
     * @param alias The alias of the exploit to retrieve.
     * @return The exploit with the given alias, or null if not found.
     */
    public Exploit getExploit(String alias) {
        if (alias == null) {
            return null;
        }
        for (Exploit exploit : exploits) {
            if (alias.equalsIgnoreCase(exploit.getAlias())) {
                return exploit;
            }
        }
        return null;
    }

    /**
     * Registers a new exploit.
     *
     * @param exploit The exploit to register, must not be null.
     * @throws IllegalArgumentException if the exploit is null.
     */
    public void register(Exploit exploit) {
        if (exploit == null) {
            throw new IllegalArgumentException("Exploit cannot be null");
        }
        exploits.add(exploit);
    }

    /**
     * Retrieves an unmodifiable list of all registered exploits.
     *
     * @return An unmodifiable list of all registered exploits.
     */
    public List<Exploit> getExploits() {
        return Collections.unmodifiableList(exploits);
    }
}
