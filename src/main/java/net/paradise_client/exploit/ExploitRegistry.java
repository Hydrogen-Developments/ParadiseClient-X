package net.paradise_client.exploit;

import com.google.common.reflect.ClassPath;
import net.minecraft.client.MinecraftClient;
import net.paradise_client.Constants;
import net.paradise_client.Helper;
import net.paradise_client.ParadiseClient;

import java.io.IOException;
import java.lang.reflect.Constructor;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * Manages and handles various exploits.
 *
 * @author SpigotRCE
 * @since 2.5
 */
public class ExploitRegistry {
    private final MinecraftClient minecraftClient;
    private final List<Exploit> exploits;

    /**
     * Constructs a new ExploitRegistry with the given Minecraft client.
     *
     * @param minecraftClient The Minecraft client instance, must not be null.
     * @throws IllegalArgumentException if minecraftClient is null.
     */
    public ExploitRegistry(MinecraftClient minecraftClient) {
        if (minecraftClient == null) {
            throw new IllegalArgumentException("MinecraftClient cannot be null");
        }
        this.minecraftClient = minecraftClient;
        this.exploits = new CopyOnWriteArrayList<>();
    }

    /**
     * Initializes the exploit registry by scanning and registering exploits from the specified package.
     *
     * @throws ExploitInitializationException if an error occurs during class scanning or exploit instantiation.
     */
    public void init() throws ExploitInitializationException {
        try {
            ClassLoader classLoader = getClass().getClassLoader();
            ClassPath classPath = ClassPath.from(classLoader);
            Class<?> minecraftClientClass = minecraftClient.getClass();

            List<ClassPath.ClassInfo> classes = classPath
                    .getTopLevelClassesRecursive("net.paradise_client.exploit.impl")
                    .stream().toList();

            for (ClassPath.ClassInfo classInfo : classes) {
                try {
                    Class<?> clazz = Class.forName(classInfo.getName(), true, classLoader);
                    if (Exploit.class.isAssignableFrom(clazz) && !clazz.isInterface() && !java.lang.reflect.Modifier.isAbstract(clazz.getModifiers())) {
                        Constructor<?> constructor = clazz.getConstructor(minecraftClientClass);
                        Exploit exploit = (Exploit) constructor.newInstance(minecraftClient);
                        register(exploit);
                    }
                } catch (NoSuchMethodException e) {
                    Constants.LOGGER.error("No suitable constructor for {} with MinecraftClient parameter", classInfo.getName(), e);
                } catch (Exception e) {
                    Constants.LOGGER.error("Failed to instantiate exploit: {}", classInfo.getName(), e);
                }
            }
            Constants.LOGGER.info("Registered {} exploits", exploits.size());
        } catch (IOException e) {
            throw new ExploitInitializationException("Failed to scan classes for exploits", e);
        }
    }


    /**
     * Executes the exploit with the specified alias.
     *
     * @param alias The alias of the exploit to execute.
     * @throws IllegalArgumentException if the alias is null or empty.
     */
    public void handleExploit(String alias) {
        if (alias == null || alias.trim().isEmpty()) {
            throw new IllegalArgumentException("Exploit alias cannot be null or empty");
        }
        Exploit exploit = getExploit(alias);
        if (exploit == null) {
            Helper.printChatMessage("Unknown exploit: " + alias);
            return;
        }
        ParadiseClient.EXPLOIT_MOD.isRunning = true;
        exploit.execute();
    }

    /**
     * Retrieves the exploit with the specified alias (case-insensitive).
     *
     * @param alias The alias of the exploit to retrieve.
     * @return The exploit with the given alias, or null if not found.
     */
    public Exploit getExploit(String alias) {
        if (alias == null) {
            return null;
        }
        for (Exploit exploit : exploits) {
            if (alias.equalsIgnoreCase(exploit.getAlias())) {
                return exploit;
            }
        }
        return null;
    }

    /**
     * Registers a new exploit.
     *
     * @param exploit The exploit to register, must not be null.
     * @throws IllegalArgumentException if the exploit is null.
     */
    public void register(Exploit exploit) {
        if (exploit == null) {
            throw new IllegalArgumentException("Exploit cannot be null");
        }
        exploits.add(exploit);
    }

    /**
     * Retrieves an unmodifiable list of all registered exploits.
     *
     * @return An unmodifiable list of all registered exploits.
     */
    public List<Exploit> getExploits() {
        return Collections.unmodifiableList(exploits);
    }
}
